/* Generated By:JavaCC: Do not edit this line. FormatDefParser.java */
package org.mxupdate.update.datamodel.format;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;

import org.mxupdate.mapping.TypeDef_mxJPO;
import org.mxupdate.update.datamodel.Format_mxJPO;
import org.mxupdate.update.util.AbstractParser_mxJPO;
import org.mxupdate.update.util.AdminPropertyList_mxJPO.AdminProperty;
import org.mxupdate.update.util.ParameterCache_mxJPO;

public class FormatDefParser_mxJPO
    extends AbstractParser_mxJPO implements FormatDefParserConstants_mxJPO {

/**
 * Parses one complete format definition.
 *
 * @param _paramCache   parameter cache
 * @param _typeDef      type definition of the format (to instantiate the
 *                      format)
 * @param _mxName       MX name of the format
 */
  final public Format_mxJPO format(final ParameterCache_mxJPO _paramCache,
                    final TypeDef_mxJPO _typeDef,
                    final String _mxName) throws ParseException_mxJPO, SecurityException, IllegalArgumentException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    final Format_mxJPO attr = (Format_mxJPO) _typeDef.newTypeInstance(_mxName);
    Token_mxJPO tmp;
    AdminProperty property;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
      case HIDDEN_TRUE:
      case HIDDEN_FALSE:
      case MIME:
      case SUFFIX:
      case TYPE:
      case VERSION:
      case VIEW:
      case EDIT:
      case PRINT:
      case PROPERTY:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
        jj_consume_token(DESCRIPTION);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "description", this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "description", this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case HIDDEN_TRUE:
        jj_consume_token(HIDDEN_TRUE);
                                                                this.setValue(attr, "hidden",       true);
        break;
      case HIDDEN_FALSE:
        jj_consume_token(HIDDEN_FALSE);
                                                                this.setValue(attr, "hidden",       false);
        break;
      case MIME:
        jj_consume_token(MIME);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "mimeType",     this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "mimeType",     this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case SUFFIX:
        jj_consume_token(SUFFIX);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "fileSuffix",   this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "fileSuffix",   this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case TYPE:
        jj_consume_token(TYPE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "type",         this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "type",         this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case VERSION:
        jj_consume_token(VERSION);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "version",      this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "version",      this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case VIEW:
        jj_consume_token(VIEW);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "commandView",  this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "commandView",  this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case EDIT:
        jj_consume_token(EDIT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "commandEdit",  this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "commandEdit",  this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case PRINT:
        jj_consume_token(PRINT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(attr, "commandPrint", this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(attr, "commandPrint", this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        break;
      case PROPERTY:
        jj_consume_token(PROPERTY);
                                                                property = new AdminProperty();this.appendValue(this.getValue(attr, "properties"), "propertiesStack", property);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          tmp = jj_consume_token(STRING);
                                                                this.setValue(property, "name", this.getString(tmp.image));
          break;
        case SINGLE:
          tmp = jj_consume_token(SINGLE);
                                                                this.setValue(property, "name", this.getSingle(tmp.image));
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException_mxJPO();
        }
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PROPERTYTO:
          case PROPERTYVAL:
            ;
            break;
          default:
            break label_2;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PROPERTYVAL:
            jj_consume_token(PROPERTYVAL);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STRING:
              tmp = jj_consume_token(STRING);
                                                                this.setValue(property, "value", this.getString(tmp.image));
              break;
            case SINGLE:
              tmp = jj_consume_token(SINGLE);
                                                                this.setValue(property, "value", this.getSingle(tmp.image));
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException_mxJPO();
            }
            break;
          case PROPERTYTO:
            jj_consume_token(PROPERTYTO);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ADMINTYPE_STRING:
              tmp = jj_consume_token(ADMINTYPE_STRING);
                                                                this.setValue(property, "refAdminType", this.getString(tmp.image));
              break;
            case ADMINTYPE_SINGLE:
              tmp = jj_consume_token(ADMINTYPE_SINGLE);
                                                                this.setValue(property, "refAdminType", this.getSingle(tmp.image));
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException_mxJPO();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STRING:
              tmp = jj_consume_token(STRING);
                                                                this.setValue(property, "refAdminName", this.getString(tmp.image));
              break;
            case SINGLE:
              tmp = jj_consume_token(SINGLE);
                                                                this.setValue(property, "refAdminName", this.getSingle(tmp.image));
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException_mxJPO();
            }
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException_mxJPO();
          }
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
        this.prepareObject(_paramCache, attr);
        {if (true) return attr;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public FormatDefParserTokenManager_mxJPO token_source;
  SimpleCharStream_mxJPO jj_input_stream;
  /** Current token. */
  public Token_mxJPO token;
  /** Next token. */
  public Token_mxJPO jj_nt;
  private int jj_ntk;

  /** Constructor with InputStream. */
  public FormatDefParser_mxJPO(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FormatDefParser_mxJPO(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream_mxJPO(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FormatDefParserTokenManager_mxJPO(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Constructor. */
  public FormatDefParser_mxJPO(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream_mxJPO(stream, 1, 1);
    token_source = new FormatDefParserTokenManager_mxJPO(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Constructor with generated Token Manager. */
  public FormatDefParser_mxJPO(FormatDefParserTokenManager_mxJPO tm) {
    token_source = tm;
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(FormatDefParserTokenManager_mxJPO tm) {
    token_source = tm;
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  private Token_mxJPO jj_consume_token(int kind) throws ParseException_mxJPO {
    Token_mxJPO oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token_mxJPO getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  final public Token_mxJPO getToken(int index) {
    Token_mxJPO t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  public ParseException_mxJPO generateParseException() {
    Token_mxJPO errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException_mxJPO("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
